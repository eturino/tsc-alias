{"version":3,"file":"replacers.js","sourceRoot":"","sources":["../../src/helpers/replacers.ts"],"names":[],"mappings":"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","sourcesContent":["import * as normalizePath from 'normalize-path';\nimport * as findNodeModulesPath from 'find-node-modules';\nimport { join } from 'path';\nimport { IConfig, ReplacerOptions } from '../interfaces';\nimport { existsSync, promises as fsp } from 'fs';\nimport { replaceSourceImportPaths, resolveFullImportPaths } from '../utils';\n\nexport async function importReplacers(\n  config: IConfig,\n  replacers: ReplacerOptions,\n  cmdReplacers?: string[]\n) {\n  const dir = process.cwd();\n  const node_modules: string[] = findNodeModulesPath({ cwd: dir });\n  const defaultReplacers: ReplacerOptions = {\n    default: {\n      enabled: true\n    },\n    BaseUrl: {\n      enabled: true\n    }\n  };\n\n  let merged: ReplacerOptions = {\n    ...defaultReplacers,\n    ...replacers\n  };\n\n  cmdReplacers?.forEach((v) => {\n    merged[v] = {\n      enabled: true,\n      file: v\n    };\n  });\n\n  const entries = Object.entries(merged);\n  for await (const replacer of entries) {\n    if (replacer[1].enabled) {\n      // Importing default replacers.\n      if (Object.keys(defaultReplacers).includes(replacer[0])) {\n        const replacerModule = await import(\n          `../replacers/${replacer[0]}.replacer`\n        );\n        config.replacers.push(replacerModule.default);\n      }\n\n      const file = replacer[1]?.file;\n      if (!file) {\n        continue; // When file is undefined don't try to import.\n      }\n      // Try to import replacer.\n      const tryImportReplacer = async (targetPath: string) => {\n        const replacerModule = await import(targetPath);\n        config.replacers.push(replacerModule.default);\n        config.output.info(`Added replacer \"${file}\"`);\n      };\n\n      // Look for replacer in cwd.\n      const path = normalizePath(dir + '/' + file);\n      if (existsSync(path)) {\n        try {\n          await tryImportReplacer(path);\n          continue;\n        } catch {}\n      }\n\n      // Look for replacer in node_modules.\n      for (const targetPath of node_modules.map((v) => join(dir, v, file))) {\n        try {\n          await tryImportReplacer(targetPath);\n          continue;\n        } catch {}\n      }\n\n      config.output.error(`Failed to import replacer \"${file}\"`);\n    }\n  }\n}\n\n/**\n * replaceAlias replaces aliases in file.\n * @param config configuration\n * @param file file to replace aliases in.\n * @param resolveFullPath if tsc-alias should resolve the full path\n * @returns if something has been replaced.\n */\nexport async function replaceAlias(\n  config: IConfig,\n  file: string,\n  resolveFullPath?: boolean\n): Promise<boolean> {\n  const code = await fsp.readFile(file, 'utf8');\n  const tempCode = replaceAliasString(config, file, code, resolveFullPath);\n\n  if (code !== tempCode) {\n    await fsp.writeFile(file, tempCode, 'utf8');\n    return true;\n  }\n  return false;\n}\n\n/**\n * replaceAliasString  replaces aliases in the given code content and returns the changed code.\n * @param config configuration\n * @param file path of the file to replace aliases in.\n * @param code contents of the file to replace aliases in.\n * @param resolveFullPath if tsc-alias should resolve the full path\n * @returns content of the file with any replacements possible applied.\n */\nexport function replaceAliasString(\n  config: IConfig,\n  file: string,\n  code: string,\n  resolveFullPath?: boolean\n): string {\n  let tempCode = code;\n\n  config.replacers.forEach((replacer) => {\n    tempCode = replaceSourceImportPaths(tempCode, file, (orig) =>\n      replacer({\n        orig,\n        file,\n        config\n      })\n    );\n  });\n\n  // Fully resolve all import paths (not just aliased ones)\n  // *after* the aliases are resolved\n  if (resolveFullPath) {\n    tempCode = resolveFullImportPaths(tempCode, file);\n  }\n\n  return tempCode;\n}\n"]}